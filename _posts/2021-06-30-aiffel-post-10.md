---
title: "day 4 터미널로 리눅스 배우기"
excerpt: "Learning how to use Linux on Terminal"
categories:
  - Aiffel-LMS
tags:
  - Linux
toc: True
toc_sticky: True
last_modified_at: 2021-06-30T17:06:00Z


---


## 터미널로 배우는 리눅스 운영체제


개발자에게 필요한 가장 첫 번째 덕목은 무엇일까요? 많은 의견이 있을 수 있지만, 언제나 빼먹지 않고 이야기되는 것은 바로 협업 능력입니다.





### ls

```
$ ls
aiffel  data
$ ls --all
.  ..  aiffel  .cache  .conda  data  .jupyter  .local  .wget-hsts
```
이런 숨김 파일들도 ls 명령어에 --all 인자를 함께 사용하면 모두 표시할 수 있습니다.

대부분의 명령어들은 --help라는 인자를 기본으로 제공합니다. ls --help를 입력해 봅시다.

```
$ ls --help
Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.

Mandatory arguments to long options are mandatory for short options too.
  -a, --all                  do not ignore entries starting with .
  -A, --almost-all           do not list implied . and ..
      --author               with -l, print the author of each file
  -b, --escape               print C-style escapes for nongraphic characters
      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,
                               '--block-size=M' prints sizes in units of
```

- -l: 각 파일 및 폴더의 권한, 소유자, 크기, 수정일시 등 자세한 정보를 출력합니다.
- -h: 파일 크기를 바이트 수 대신 사람이 알아볼 수 있는 단위(1K, 234M, 2G 등)로 표시합니다.
- -t: 파일 수정시간 순으로 정렬해서 출력합니다. 최신 파일이 위쪽으로 표시됩니다.
- -r: 정렬 순서를 뒤집어 출력합니다. -rt의 형태로 쓰면 최신 파일이 아래쪽으로 표시되어 유용할 때가 있습니다.

한 글자 인자를 여럿 쓸 때에는 서로 붙여 쓸 수 있습니다. 즉, ls -l -a -h는 ls -lah로 쓸 수 있습니다.

```
$ ls -lah
total 32K
drwxr-xr-x 1 root root 4.0K Jun  7 05:10 .
drwxr-xr-x 1 root root 4.0K Jun  7 05:10 ..
drwxrwxrwx 2 root root    0 Jun  2 02:45 aiffel
drwxr-xr-x 1 root root 4.0K Apr 19 09:30 .cache
drwxrwsr-x 2 root root 4.0K Apr 19 09:30 .conda
drwxr-xr-x 2 root root 4.0K Jun  4 03:42 data
drwx------ 1 root root 4.0K Apr 19 09:23 .jupyter
drwxr-xr-x 3 root root 4.0K Jun  7 05:10 .local
-rw-r--r-- 1 root root  170 Apr 19 09:28 .wget-hsts
```

(Tip) ls -alrt 가 유용할 때가 많습니다.

# cd

일부 주요 폴더들의 용도 및 내용물은 다음과 같습니다. 굳이 기억할 필요는 없고, 이런 것들이 있다는 것만 알고 넘어갑시다.

- /home: 사용자별 홈 디렉토리들이 있는 곳
- /root: 최고 관리자 계정의 홈 디렉토리
- /mnt: 저장장치(HDD, SSD)가 붙는 위치
- /media: 이동식 미디어(USB 드라이브)가 붙는 위치
- /tmp: 재부팅 시 삭제될 임시 파일들을 저장하는 폴더
- /dev: 컴퓨터에 연결된 하드웨어 및 가상 기기(device)들을 가리키는 파일들
- /proc: 현재 실행 중인 프로세스들을 가리키는 파일들
- /etc: 각종 설정 파일들
- /bin: 실행 가능한 프로그램(binary)들
- /sbin: 시스템 관리용 프로그램들
- /usr: 다중 사용자 모드에서 사용 가능한 파일 및 프로그램들 (root 계정만 있는 단일 사용자 모드에서는 사용 불가)
- /var: 캐시, 로그 등 시스템 구동 간 계속 내용이 바뀌는 파일들

```
$ cd root
$ ls -l
total 500
-rw-r--r-- 1 root root 506002 Apr 19 08:55 1.6.2.zip
drwxr-sr-x 1 root root   4096 Apr 19 08:55 ttyd-1.6.2
```


### 운영체제란? 


![image](https://user-images.githubusercontent.com/46912607/123886074-9f391f80-d989-11eb-868c-62790cf7984a.png)

우리가 지금 보고 있는 것은 운영체제들 중 리눅스 계열의 우분투(Ubuntu)라는 운영체제입니다. 조금 더 친숙한 운영체제로는 마이크소프트의 윈도우즈나, 애플의 맥 OS, iOS, 구글의 Android, ChromeOS 등이 있습니다.

그런데 위 그림에서 도대체 어디가 운영체제냐구요? 위 그림에서 CPU, Memory, SDD 등 각종 디바이스를 통합관리하면서 그 연산자원을 수많은 어플리케이션들에게 분배하는 자리에 있는 것은 바로 커널(Kernel)이라는 것입니다. 운영체제=커널이라고 할수는 없겠지만 커널은 보안, 자원관리, 디바이스 인터페이스 추상화 등 바로 대저택의 집사와 같은 역할을 하는 운영체제의 가장 핵심적인 구성요소입니다.

### 커널

운영체제의 내부는 알맹이인 커널(kernel)과 껍데기인 셸(shell)로 이루어져 있습니다. 우분투의 커널은 리눅스이고, 마이크로소프트 윈도우(Windows)의 경우 2000 이후의 버전은 Windows NT라는 커널을 사용하며, 맥 OS(macOS)의 경우에는 XNU(XNU is Not Unix의 약자)라는 커널을 사용합니다.

윈도우를 제외한 운영체제들은 사실상 서로 사촌지간이라고 볼 수 있는데, 여기에는 약간의 역사가 있습니다. 태초에 유닉스(Unix)라는 상용 운영체제(겸 해당 운영체제를 위한 커널)가 있었습니다. 이를 기반으로 미국 UC 버클리에서 개발한 BSD 운영체제가 나오자, 미국 카네기 멜론 대학교에서 BSD를 위해 Mach 커널을 개발합니다. 1985년 애플에서 쫓겨났던 스티브 잡스가 창업한 NeXT에서는 이 Mach 커널을 사용해 XNU라는 커널을 만듭니다. 이후 NeXT가 (스티브 잡스와 함께) 애플에 흡수되면서 XNU는 맥 OS, iOS (및 iPadOS, tvOS, watchOS..) 운영체제에서 커널로 사용되게 됩니다.

리눅스 커널 또한 유닉스와 관련이 깊은데, 1991년 핀란드에서 당시 컴퓨터 공학과 학생 리누스 토발즈(Linus Torvalds)가 유닉스의 무료 및 공개 버전을 지향하여 만든 것이 리눅스입니다. 여기서 명심할 점은 리눅스가 그 자체로 운영체제가 아니라, 운영체제를 위한 커널이라는 사실인데, 우리가 흔히 리눅스 운영체제라 부르는 것들은 사실 이 리눅스를 커널로써 사용하는 운영체제들을 가리키며, 우분투나 Android, ChromeOS 말고도 Debian, CentOS, Red Hat Enterprise Linux 등 다양한 종류가 있습니다.

즉, 맥 OS의 XNU 커널과 우분투의 리눅스 커널은 역사적 배경 때문에 모두 유닉스와 유사하며, 유닉스 표준(POSIX)과 일부 호환성이 제공됩니다. 이런 유사성은 두 운영체제 모두 동일하게 bash를 기본 셸로 제공하는 점에서도 찾아볼 수 있습니다.

### 셸

셸은 말 그대로 눈에 보이는 운영체제의 껍데기인데, 그래픽 기반의 GUI(Graphical User Interface) 셸과 텍스트 기반의 CLI(Command Line Interface) 셸로 구분할 수 있습니다.

**GUI 셸**

의 경우, 윈도우에는 우리에게 친숙한 시작 버튼을 포함하는 셸을 Windows shell이 라 부르고, 맥 OS의 경우는 Aqua라는 이름을 갖고 있습니다.

**CLI 셸**

로는 윈도우 운영체제의 cmd.exe와 PowerShell이 있고, 우분투 및 맥 OS에서는 CLI 셸로서 기본으로 sh와 여기에 몇 가지 편의기능을 덧붙인 bash가 설치되어 있습니다. 이 외에도 csh, fish, zsh 등 다양한 CLI 셸을 직접 설치하여 사용할 수 있습니다. 또한 zsh처럼 테마 및 플러그인을 지원하는 셸의 경우 모양과 편의기능을 입맛에 따라 꾸밀 수 있습니다.

![image](https://user-images.githubusercontent.com/46912607/123886591-c3493080-d98a-11eb-9fa7-357372e7170c.png)

### 프로세스 (process)

프로그램은 컴퓨터가 수행할 작업을 기록해 놓는데 프로그램이 실제로 작업으로써 수행될 때 운영체제는 이를 프로세스(process)라는 단위로 관리 하게 됩니다. 

운영체제는 프로세스 단위로 메모리와 CPU 연산 등 컴퓨팅 자원을 분배합니다.

- 메모리 관리: 운영체제는 프로세스가 컴퓨터의 전체 메모리 어디든지 쓸 수 있도록 하는 것이 아니라 가상 메모리(virtual memory)로써 일부만 떼어서 제공해줌으로써, 다른 프로세스의 메모리 또는 운영체제 자체가 사용하고 있는 커널 메모리를 훔쳐볼 수 없도록 합니다. 이것을 운영체제의 중요한 보안 기제 중 하나인 프로세스 격리(process isolation)라고 부르며, 때문에 프로세스들이 서로 소통하기 위해서는 별도로 허용된 프로세스 간 통신 (Inter-Process Communication, IPC) 기법들을 사용해야 합니다.

- CPU 자원 관리: 메모리는 주소로서 프로세스에게 제공되지만, CPU 연산의 경우 코어 단위로 프로세스에 제공됩니다. 프로세스는 스레드(thread)라는 단위로 코어를 하나씩 사용할 수가 있는데, 프로세스가 하나 시작되면 기본적으로 하나의 스레드를 가지고 시작하지만, 개발자는 프로그램이 더 많은 스레드를 사용하도록 설계하여 다중 CPU 코어의 이점을 극대화할 수 있습니다.

프로세스는 운영체제가 메모리를 할당하는 작업단위라면, 스레드는 프로세스가 할당받은 메모리를 활용하는 실행단위입니다.

![image](https://user-images.githubusercontent.com/46912607/123886855-51bdb200-d98b-11eb-926a-f719308b7a49.png)

하나의 프로그램 안에서 여러개의 프로세스를 활용하는 것을 멀티프로세싱(Multiprocessing), 하나의 프로세스 안에서 여러개의 스레드를 활용하는 것을 멀티스레딩(Multithreading)이라고 합니다.

### 터미널(terminal)

우분투에서 Cloud shell 열기를 눌러보면 아까 본 텍스트 화면이 들어있는, 흔히 터미널 또는 콘솔이라고도 부르는 창이 열립니다. 이 창 내부에서 텍스트로 조작하는 환경은 위에서 배웠듯이 CLI 셸입니다. 이 창을 여는 프로그램은 엄밀히 말하면 터미널이 아니라, 정확히는 그래픽 환경에서 터미널을 모사하는 터미널 에뮬레이터입니다.

터미널이라는 이름은 개인용 컴퓨터(PC)가 등장하기 전의 시절, 실제 연산을 담당하는 크고 비싼 메인프레임 컴퓨터와는 별도로, 입출력만 담당하는 CRT 모니터와 키보드로 구성된 말단(=terminal)의 기기에서 유래한 명칭입니다.


터미널 에뮬레이터를 열고 몇 가지 명령어를 새로 배보기~

👍️ ps: 현재 터미널과 관련된 프로세스 목록을 출력합니다.
👍️ ps -ef: 모든 터미널에서 현재 실행중인 프로세스 목록 및 부가정보를 출력합니다.

![image](https://user-images.githubusercontent.com/46912607/123887116-e1636080-d98b-11eb-8f25-6c4b491a8780.png)

- PID는 process ID 번호
- TTY는 해당 프로세스가 붙어있는 teletype(터미널)입니다. 
- 0번 가상 터미널(pts, pseudo teletype slave)에 우리가 방금 실행한 ps 명령어와, 해당 명령어를 실행한 셸 bash가 떠있습니다. 
- TTY 칸에 ?가 표시된 프로세스들은 터미널에 부착되지 않은 프로세스들입니다.

프로세스 하나 죽여보기~

👍️ grep: 입력으로 전달된 내용에서 특정 문자열을 포함한 라인만 선택해서 출력합니다. 파이프를 통해 다른 명령문 실행결과와 결합해서 사용할 때 특히 유용합니다.

❤️ sudo: 이어지는 명령을 최고 관리자 권한으로 실행합니다.

👍️ kill: PID에 해당하는 프로세스에 시그널을 보냅니다.

![image](https://user-images.githubusercontent.com/46912607/123887287-34d5ae80-d98c-11eb-9656-598c99dc6fc0.png)

이렇게 프로세스가 커널에게 요청을 전달하는 기능을 시스템 콜(system call)이라고 합니다. 즉, 시스템 콜은 운영체제의 커널이 프로그램에 제공하는 인터페이스이며, 프로세스가 직접 할 수 없는 프로세스 제어(kill 등), 파일 조작(폴더 생성 mkdir, 파일 읽기 read 등), 장치 및 자원 관리, 네트워크 통신 등을 가능케 합니다. 반대로 보면, 각 프로세스는 커널을 통하지 않고서는 파일이나 장치, 또는 다른 프로세스에 간섭할 수 없다는 뜻이 됩니다.

참고로 kill은 그 자체로 프로세스를 죽이는 명령이 아니라, 프로세스에 신호를 보내는 명령어입니다. 강제종료하는 KILL 외에도, 프로그램 실행 중에 Ctrl+C를 누르면 전달되는 INT (interrupt) 신호나, 프로세스를 종료하기 전에 해당 프로세스에게 해명할 기회를 주는 TERM (terminate) 신호도 있습니다.

### 프로그램과 환경변수

👌️ which: 명령어의 전체 경로를 출력합니다.

![image](https://user-images.githubusercontent.com/46912607/123887630-cf35f200-d98c-11eb-9224-0cf5a1ab0311.png)

셸에서 단어 앞에 $가 붙으면 환경 변수(environment variable) 를 의미합니다. 파이썬의 변수처럼, 환경 변수는 운영체제가 프로세스 단위로 사용하는 변수입니다. 즉, 우리가 echo $PATH는 PATH라는 이름의 환경 변수($)의 값을 출력(echo)하라는 뜻입니다.

PATH 환경 변수는 셸이 프로그램을 실행할 때 참조할 경로들을 나타냅니다

![image](https://user-images.githubusercontent.com/46912607/123887746-01475400-d98d-11eb-8669-19e06e7f58eb.png)

👌️ env: 명령어가 제공된다면 해당 명령어를 새로운 환경에서 실행합니다. 명령어가 제공되지 않은 경우 현재 환경의 정보를 출력합니다.

![image](https://user-images.githubusercontent.com/46912607/123887822-1cb25f00-d98d-11eb-927a-f0a1290c5bc5.png)

### 패키지 관리자 

우분투 운영체제는 공식적으로 APT(Advanced Packaging Tool)라는 패키지 관리자(package manager) 를 제공합니다.

이제 APT로 우분투에 htop이라는 프로그램을 설치해 보겠습니다. htop은 CPU 및 메모리 사용량을 시각화하고, 프로세스 별 CPU 사용량을 표시해 주는 프로그램입니다.

❤️ apt-get: APT 패키지 관리자를 통해 공인 저장소에서 패키지를 가져다 설치하거나 제거합니다.

![image](https://user-images.githubusercontent.com/46912607/123889114-c7c41800-d98f-11eb-9252-59cbf82e3570.png)

![image](https://user-images.githubusercontent.com/46912607/123889358-56389980-d990-11eb-8f1c-e3c242a2b173.png)

![image](https://user-images.githubusercontent.com/46912607/123889287-24bfce00-d990-11eb-8989-14f5e62cf776.png)

제는 설치만큼 쉽습니다. apt-get 뒤에 install 대신 remove를 넣어서 프로그램만을 제거하거나, purge를 넣어 해당 프로그램의 설정 파일까지 모두 삭제시킬 수 있습니다. 만약 중간에 확인([Y/n])을 물으면 y를 누르고 엔터를 쳐서 제거를 승인합니다.

![image](https://user-images.githubusercontent.com/46912607/123889433-7a947600-d990-11eb-9e08-4aa59cc3f7c6.png)


### 사용자와 권한

**sudo 명령어**

윈도우에서 무언가를 설치할 때 가끔 보게 되는 "관리자 권한으로 실행" 경고창이나, 유닉스 계열 운영체제에서 사용하는 sudo(Switch User Do) 명령어가 바로 이 역할을 하며, 일반 사용자가 잠시 최고 관리자(또는 다른 사용자) 권한으로 행동할 수 있게 해줍니다. 매번 확인해야 하는 것이 번거로울 수 있지만, 한 번 더 확인함으로써 실수를 방지할 기회를 준다는 것 외에도 모든 권한이 아닌 일부 권한만 허용할 수 있는 등 다양한 보안상의 이점이 있습니다.

**사용자 그룹**

사용자들이 여러 명 있을 때, 쉽게 묶어서 관리하는 개념이 바로 그룹(group)입니다. 예를 들어 한 사용자가 sudo 명령어를 실행하기 위해서는, 동일한 이름(sudo)라는 이름의 그룹에 속해있어야 합니다.

❤️ cat: 하나 이상의 텍스트 파일을 순서대로 출력합니다. 고양이가 아니라 concatenate(이어붙이다)의 약자입니다.

![image](https://user-images.githubusercontent.com/46912607/123889750-18884080-d991-11eb-8d9f-11c3c9ed1b0b.png)

- 사용자들의 목록은 /etc/passwd
- 비밀번호는 최고 관리자만 접근 가능한 /etc/shadow 파일에 암호화되어 저장됩니다.

**접근 권한**

프로그램 실행 권한은 파일 접근 권한과 동일한 방법으로 구분합니다.

![image](https://user-images.githubusercontent.com/46912607/123889877-4c636600-d991-11eb-90df-520900d9433c.png)

 한번 이걸 변경해볼까요? 현재 디렉토리의 소유 사용자를 root로, 소유 그룹은 adm으로 변경했다가 복구해 보겠습니다.

 👍️ chown: 대상 파일의 소유 사용자와 그룹을 변경합니다.

 ![image](https://user-images.githubusercontent.com/46912607/123890023-83d21280-d991-11eb-89aa-7023e5ae24de.png)

 ls -lah의 첫 열을 보면 drwxr-xr-x라고 무언가 적혀있는데, 이 부분이 바로 권한을 표기하는 부분입니다. 첫 글자인 d는 해당 파일이 디렉토리인지 또는 일반 파일인지 여부를 나타냅니다. 
 그 뒤를 잇는 글자들은 각각 3 글자씩 **소유 사용자 , 소유 그룹 , 기타 사용자** 에게 허용된 읽기 **(read, r) , 쓰기(write, w) , 실행하기(execute, x)**

 세 자리 이진수 숫자를 해석하면 사용자, 그룹, 기타 사용자에게 부여된 권한을 1자리 십진수 숫자로 나타낼 수 있습니다. 예를 들어 rwxr-xr-x를 이진수로 나타내면 111101101이고, 이는 구분 별로 다음과 같습니다.

- 사용자: 이진수 111 = 십진수 7
- 그룹: 이진수 101 = 십진수 5
- 기타 사용자: 이진수 101 = 십진수 5
- 종합: 755

**chmod 명령어**

👍️ chmod: 대상 파일의 권한을 변경합니다.

![image](https://user-images.githubusercontent.com/46912607/123890253-dd3a4180-d991-11eb-9331-b1539b604104.png)


### 하드웨어 

![image](https://user-images.githubusercontent.com/46912607/123890347-03f87800-d992-11eb-9ca1-8d6024024271.png)

마더보드의 CPU Socket에는 CPU(Central Processing Unit, 중앙처리장치)가 올라갑니다. 실제로 CPU 칩의 크기는 얇지만, 보통 그 위에 냉각팬을 올리기 때문에 하드웨어를 직접 보면 커보입니다. 이 얇은 칩은 반도체인 실리콘 웨이퍼 위에 직접회로(Integrated Circuits, IC)를 포토리소그래피(photolithography) 공정을 통해 회로를 인쇄해 만듭니다.

**기계어**


이렇게 제작된 CPU 칩이 처리할 수 있는 명령어는 기계어라고도 하며, 우리가 사용하는 프로그래밍 언어와는 많이 다릅니다. 기계어로 프로그램을 직접 짜기에는 워낙 복잡하고 비효율적이기에 C, C++, Python 등 인간이 이해할 수 있는 프로그래밍 언어들이 만들어졌습니다. 이렇게 인간이 이해할 수 있는 언어로 짠 프로그램을 CPU에서 실행할 수 있는 기계어로 번역하고 최적화하는 과정이 바로 컴파일입니다.

**명령어 집합**


회로 설계는 Intel, AMD 등 제조사마다 다르지만, 지원하는 연산 세트를 나타내는 명령어 집합(instruction set)은 데스크탑용 CPU 간 상당 부분 호환됩니다. 다만 스마트폰 등 모바일 기기에 들어가는 CPU는 이야기가 다른데, 대부분 ARM 사의 RISC(Reduced Instruction Set Computer)라는 구조를 가지고, 지원하는 명령어는 더 적지만 전력을 더 적게 소비하는 방향으로 설계됩니다.

흥미롭게도 ARM 회사는 더 이상 직접 칩을 만들지 않고, 설계만 만들어 라이센스를 판매합니다. 이 설계를 원형으로 삼성전자(Exynos 등), 애플(A11 등), 퀄컴(SnapDragon 등) 등 회사가 자신들의 목적에 맞게 변경하여 각자 칩을 생산합니다.

**메모리와의 관계**


CPU를 구분할 때에는 32bit와 64bit로 구분하기도 하는데, 이는 CPU가 한 번에 읽고 쓸 수 있는 데이터의 크기를 나타냅니다. 이 크기가 중요한 이유 중 하나는 사용 가능한 메모리 주소의 범위에 영향을 주기 때문입니다.

이론적으로 32bit 컴퓨터에서는 2의 32승인 약 42억 개 메모리 주소공간만 사용할 수 있습니다. 1개 주소공간이 1 Byte라면 4GB 크기의 메모리 용량만 표기할 수 있기 때문에, 그 이상의 RAM을 사용할 수 없다는 큰 제한사항이 있었습니다.

**CPU의 성능과 발전**


CPU의 성능을 판단하는 주요 척도 중 하나는 초당 처리 속도의 기준인 클럭(clock)입니다. 하지만 요새 나오는 CPU를 보면 클럭이 4GHz에서 더 이상 발전하기보다는, 동시에 더 많은 스레드를 처리할 수 있도록 코어 수를 늘리는 방향으로 제조되고 있습니다. 이는 처리 속도를 높이기 위해 소비 전력을 높였다가는 물리적으로 냉각시키기가 너무 어려워지고, 그렇다고 전압을 낮춰서 낮은 전력으로 동작시키기에는 전류가 밖으로 누설되고, 그러면 전력과 전압을 모두 적절하게 유지하면서 집적도를 높이기에는 공정이 너무 미세해지면서(1~5 나노미터) 수율도 떨어지고, 현재의 소재들로는 양자 터널링 현상으로 인해 전자가 닫혀있는 게이트를 그냥 뛰어넘어버리게 되는 복잡한 물리적인/경제적인 이유 때문입니다.

**다른 연산장치**


이러한 한계로 인해 최근에는 CPU 외에도 특정 작업에 특화된 연산장치들이 떠오르고 있습니다.

그래픽 연산을 위한 GPU(Graphical Processing Unit)이 그 중 하나입니다. CPU보다 이해할 수 있는 명령어는 훨씬 적지만, 코어 수를 훨씬 늘리는 방법으로 다차원 행렬 연산에 특화했습니다. 비유하자면 8 코어 CPU가 박사학위를 소지한 수학자 8명이라면, GPU는 (사칙연산밖에 못하지만 계산을 틀리지는 않는) 초등학생 3,000명을 모아놓은 것입니다. 복잡한 수식을 처리한다면 박사들이 유리하겠지만, 초등학교 수학 전집 100권을 빠르게 처리하기에는 초등학생들이 더 유리하겠지요.

딥러닝도 그래픽 연산과 유사하게 다차원 행렬을 계산하기 때문에 GPU를 많이 사용하지만, 최근에는 구글에서 딥러닝 전용으로 만든 TPU(Tensor Processing Unit) 처럼 전용 칩이 개발되고 있습니다.

이 외에 작업에 맞게 직접 설계하여 생산하는 ASIC(Application-Specific Integrated Circuit, 어플리케이션 특화 집적회로) 도 있으며, 그때그때 회로를 직접 프로그래밍해서 사용할 수 있는 FPGA(Field-Programmable Gate Array) 칩도 다양한 산업 분야에서 활용되고 있습니다.

**저장장치**


컴퓨터의 주 저장장치는 RAM(Random Access Memory) 입니다. RAM은 비싸서 용량을 쉽게 늘리기도 어렵고, 전원이 꺼지면 데이터가 사라집니다.

반면에 보조 저장장치인 HDD(Hard Disk Drive) 나 SSD(Solid State Drive) 는 가격도 비교적 저렴하고, 전원이 꺼져도 데이터는 그대로 보존됩니다.

![image](https://user-images.githubusercontent.com/46912607/123890723-b29cb880-d992-11eb-83fc-5f0030e5ff68.png)

**딥러닝과 저장장치**


GPU를 쓰면 '연산'이 빨라져 딥러닝 모델이 무조건 빨라질 것 같지만, 사실 모델을 학습시키다 보면 속도에 병목 지점이 GPU/CPU 처리속도가 아닌 경우도 많습니다. (고화질 이미지로 모델을 학습시키는데 속도가 너무 느렸던 경우가 있으신가요?)

데이터를 읽어오는 데에 시간이 너무 많이 소요되고 있다면, 저장장치를 SSD로 변경하거나, 미리 여러 개의 스레드를 사용하여 RAM 메모리에 올려두는 방법으로 해결할 수 있습니다.


### 클라우드와 가상화


**클라우드 컴퓨팅**


닷컴버블 초기, 미국의 전자상거래 업체 아마존(Amazon)은 주요 연휴마다 고객들이 몰려 서버가 다운되는 일을 겪었습니다. 그렇다고 연휴 기간의 최대 수요에 맞춰 평상시에도 많은 서버들을 유지하고 있자니 비용이 만만치 않다는 문제가 있었습니다. 이 문제가 자신들에게만 해당되지 않는다는 점을 깨달은 아마존은, 아마존 웹 서비스(Amazon Web Services) 라는 자회사를 설립하여, 수요에 따라 그때그때 서버를 빌렸다가 반납하는 서버 임대업을 시작합니다.

아마존은 한 대의 물리적인 서버를 여러 개의 가상 서버로 쪼개어 판매하기 시작했습니다. 클라우드 컴퓨팅이라는 말은 그 이전부터 존재했지만, 이때부터 본격적인 상업적 클라우드 컴퓨팅 시대가 시작됩니다.

**가상화**


가상화(virtualization) 는 이처럼 하나의 컴퓨터를 쪼개어 여러 대의 컴퓨터가 있는 것처럼 사용하게 하는 기술입니다. 가상화에서 실제 물리적인 서버를 호스트(host), 그 안에서 돌아가는 가상 서버를 게스트(guest) 라고 합니다.

가상화에는 여러 가지 종류가 있습니다. 가상머신(Virtual Machine) 가상화의 경우 게스트 자체에 운영체제가 돌아가지만, 컨테이너(Container) 가상화 의 경우, 마치 화장실과 주방을 공유하는 것처럼, 게스트들이 호스트의 운영체제 커널을 공유합니다. 물론 커널의 기능만 공유할 뿐, 프로세스나 자원 등은 서로 철저히 격리하여 서로 간섭할 수 없도록 하는 것이 핵심기술입니다.

도커(Docker) 는 이런 컨테이너 가상화를 손쉽게 제공하는 프로그램입니다. 한 곳에서 실행 환경(우분투 버전, 라이브러리, 필요한 프로그램들)을 컨테이너로 구성해놓은 다음에 그걸 그대로 클라우드로 가져가서 실행하거나, 굳이 클라우드가 아니어도 내 컴퓨터에서 여러 개의 독립된 작업 환경을 구분하는 데에 사용할 수 있습니다.

그렇다고 가상화가 무조건 클라우드 컴퓨팅과 함께하는 개념은 아닙니다. 내 컴퓨터에서 파이썬 버전을 여러 가지 사용하고 각각 패키지를 구분하여 관리할 수 있게 해주는 아나콘다(Anaconda)나 VirtualEnv는 클라우드 컴퓨팅과 크게 관계가 없지만, 가상화의 한 종류로 볼 수 있습니다.

### 셀 심화 편리한 기능


- 터미널 에뮬레이터에서 무언가를 복사하거나 붙여넣을 때에는 Ctrl+Shift+C, Ctrl+Shift+V를 사용해야 합니다.
- 위아래 화살표를 통해 이전에 실행한 명령들을 다시 입력할 수 있습니다.
- history 명령을 통해 기존에 실행한 명령들을 표시할 수 있습니다. 여기서 나오는 번호를 참고하여 !번호를 실행하면 해당 번호의 명령이 다시 실행됩니다.
- Ctrl+A, Ctrl+E를 통해 명령어의 앞, 뒤로 커서를 이동할 수 있습니다.
- clear 명령어 또는 Ctrl+L을 통해 기존에 터미널에 출력되었던 내용을 깨끗이 지울 수 있습니다.
- 실수로 Ctrl+z를 눌러 프로세스를 중지시켰다면, fg를 통해 다시 재개시킬 수 있습니다.
- 실수로 vi 편집기에 처음 들어갔다면, Ctrl+C 또는 Esc를 누른 뒤 :q!를 입력하고 엔터를 눌러 편집기를 종료할 수 있습니다.
- sudo apt install curl 및 curl parrot.live를 통해 춤추는 앵무새를 볼 수 있습니다.( 클라우드에서는 작동이 안되니 로컬에서 테스트 해보세요 !)

- 셸 환경

👍history: 셸 명령어 이력을 출력합니다.


👍man: 프로그램의 매뉴얼 페이지를 출력합니다.


👌which: 명령어의 전체 경로를 출력합니다.


👌export: 셸 변수나 함수를 현재 환경으로 내보냅니다.


👌env: 명령어가 제공된다면 해당 명령어를 새로운 환경에서 실행합니다. 명령어가 제공되지 않은 경우 현재 환경의 정보를 출력합니다.


- 텍스트 처리

❤️echo: 뒤이어 입력한 내용을 출력합니다.


❤️cat: 하나 이상의 텍스트 파일을 순서대로 출력합니다.


👍sort: 입력된 텍스트를 줄 단위로 정렬합니다.


👍less: 텍스트 파일의 내용을 자유롭게 조회하고 검색합니다.


👍head: 텍스트 파일의 앞 몇 줄만 출력합니다.


👍tail: 텍스트 파일의 마지막 몇 줄만 출력합니다.


👍cut: 텍스트를 구분자(delimiter)에 따라 나눕니다.


👍uniq: 텍스트 중 중복 값들을 제거합니다.


👍grep: 정규식을 활용해 텍스트를 검색합니다.


👍wc: 텍스트를 단어, 줄, 문자 등 단위로 셉니다.


👌comm: 텍스트 파일을 비교합니다.


👌zcat: 압축된 텍스트 파일을 출력합니다.


👌sed: 정규식을 활용해 텍스트를 변형합니다.


👌awk: 텍스트를 스캔하고 변형합니다.


- 파일 제어 및 이동

❤️ls: 현재 디렉토리 내의 파일 및 폴더들을 출력합니다.


❤️cd: Change Directory의 약자로, 뒤에 따라오는 폴더로 내가 있는 셸의 현재 위치를 이동시킵니다.


❤️cp: 파일을 복사합니다.


❤️mv: 파일을 이동합니다.


❤️rm: 파일을 삭제합니다. 폴더를 삭제하기 위해서는 -r (recursive) 옵션을, 빈 폴더가 아니더라도 내부까지 삭제하려면 -f (force) 옵션을 함께 사용해야 합니다.


👍chown: 대상 파일의 소유 사용자와 그룹을 변경합니다.


👍chmod: 대상 파일의 권한을 변경합니다.


👍find: 파일을 찾습니다.


👍pwd: Present Working Directory의 약자입니다. 현재 내가 >위치한 디렉토리 위치를 출력합니다.


👌ln: 파일에 대한 링크를 생성합니다.


👌touch: 파일 접근 및 수정 시간을 변경합니다. 빈 파일을 만드는데도 사용할 수 있습니다.


👌tar: 파일 및 폴더를 하나의 아카이브 파일로 통합하고 압축합니다.


👌mount: 새로운 저장장치를 파일시스템으로서 추가합니다.


👌rename: 여러 파일들의 이름을 규칙에 따라 한번에 변경합니다.


👌df: 파일시스템의 남은 용량을 표시합니다.


- 시스템 및 프로세스 제어

❤️sudo: 이어지는 명령을 최고 관리자 권한으로 실행합니다.


❤️apt-get: APT 패키지 관리자를 통해 공인 저장소에서 패 >키지를 가져다 설치하거나 제거합니다.


👍ps: 현재 프로세스 목록을 출력합니다.


👍kill: PID에 해당하는 프로세스에 시그널을 보냅니다.


👌fg: 배경에서 실행되는 작업을 전경(foreground)으로 가져옵니다.


👌bg: 작업을 배경(backgound)으로 보냅니다.


👌jobs: 전경 및 배경 작업의 목록을 표시합니다.


- 기타

❤️ssh: 원격으로 셸에 접속합니다.


👍tmux: 여러 개의 셸 세션을 관리하고, 터미널 접속이 끊어지더라도 셸 세션을 유지합니다.


👍watch: 이어지는 명령을 주기적으로 실행하여 표시합니다.


👍curl: 주어진 URL과 통신합니다.


👍wget: 네트워크를 통해 파일을 다운로드합니다.


👍scp: SSH를 통해 원격으로 파일을 전송합니다.


👌ssh-keygen: SSH 공개키 비밀키 쌍을 생성합니다.


👌ssh-copy: SSH 공개키를 해당 서버에 등록합니다.


👌rsync: 원격으로 파일을 동기화합니다.


👌xarg: 명령어를 구성하여 실행합니다. 이전 명령에서 인자를 넘겨받아 실행하거나, 다중 프로세스를 사용하여 명령을 병렬로 실행하는 등의 작업이 가능합니다.


👌cron: 주기적으로 실행될 명령을 등록합니다.


👌htop: 프로세스 목록 및 자원 사용량을 시각적으로 표시합니다.

